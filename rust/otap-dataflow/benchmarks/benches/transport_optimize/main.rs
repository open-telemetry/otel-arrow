// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

//! Benchmarks for adding and removing transport optimized encoding

use std::hint::black_box;
use std::io::{Read, Write};
use std::sync::Arc;

use arrow::array::{
    Array, BooleanArray, DictionaryArray, Float64Array, Int64Array, RecordBatch, StringArray,
    StringBuilder, UInt8Array, UInt16Array,
};
use arrow::compute::cast;
use arrow::datatypes::{DataType, Field, Schema, UInt16Type};
use criterion::{BenchmarkId, Criterion, criterion_group, criterion_main};
use otap_df_otap::fake_data_generator::config::{Config, TrafficConfig};
use otap_df_otap::fake_data_generator::semconv_signal::semconv_otlp_logs;
use otap_df_pdata::OtapArrowRecords;
use otap_df_pdata::otap::transform::materialize_parent_id_for_attributes;
use otap_df_pdata::otlp::attributes::AttributeValueType;
use otap_df_pdata::proto::OtlpProtoMessage;
use otap_df_pdata::proto::opentelemetry::arrow::v1::ArrowPayloadType;
use otap_df_pdata::proto::opentelemetry::logs::v1::LogsData;
use otap_df_pdata::schema::consts;
use otap_df_pdata::testing::round_trip::otlp_to_otap;
use prost::Message;
use weaver_common::vdir::VirtualDirectoryPath;

#[cfg(not(windows))]
use tikv_jemallocator::Jemalloc;

#[cfg(not(windows))]
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

/// Generate a batch of fake logs using weaver. This function stores the logs in the /tmp
/// directory, so that subsequent benchmark runs will use the same data. This makes
/// comparing results between benchmark runs a more reliable indicator of performance change
#[allow(clippy::print_stdout)]
fn gen_fake_logs_batch(batch_size: usize) {
    let file_path = format!("/tmp/input_{batch_size}.proto");

    // Check if file already exists
    if std::path::Path::new(&file_path).exists() {
        println!("File {} already exists, skipping generation", file_path);
        return;
    }

    let registry_path = VirtualDirectoryPath::GitRepo {
        url: "https://github.com/open-telemetry/semantic-conventions.git".to_owned(),
        sub_folder: Some("model".to_owned()),
        refspec: None,
    };

    let traffic_config = TrafficConfig::new(None, None, 10000, 1, 1, 1);
    let config = Config::new(traffic_config, registry_path);
    let registry = config
        .get_registry()
        .expect("registry init OK")
        .expect("registry exist");
    let logs = semconv_otlp_logs(batch_size, &registry);
    let mut bytes = Vec::new();
    logs.encode(&mut bytes).expect("can encode logs");
    let mut file = std::fs::File::create(&file_path).expect("can create tmp file");
    file.write_all(bytes.as_ref())
        .expect("can write log proto bytes to tmp file");
    println!("Generated new bench data {}", file_path);
}

/// Reads the serialized logs from the /tmp directory. This function expects the logs to be
/// generated by the `gen_fake_logs_batch` function before it is called. It can also inject
/// some logs into one of the attribtues values array, to measure any overhead related to
/// null attributes.
fn read_logs_batch(
    batch_size: usize,
    with_nulls: bool
) -> OtapArrowRecords {
    let mut bytes = Vec::new();
    let mut file =
        std::fs::File::open(format!("/tmp/input_{batch_size}.proto")).expect("file exist");
    _ = file.read_to_end(&mut bytes).expect("can read");
    let log_data = LogsData::decode(bytes.as_ref()).expect("decode proto");
    let mut otap_batch = otlp_to_otap(&OtlpProtoMessage::Logs(log_data));

    // inject some nulls, just to see if/how this changes the benchmark result
    if with_nulls {
        let attrs_batch = otap_batch
            .get(ArrowPayloadType::LogAttrs)
            .expect("attrs batch present");
        let str_column = attrs_batch
            .column_by_name(consts::ATTRIBUTE_STR)
            .expect("str column present");
        let str_dict = str_column
            .as_any()
            .downcast_ref::<DictionaryArray<UInt16Type>>()
            .expect("str column dict key is u16");

        // add some nulls to exercise null-handling path
        let values = str_dict
            .values()
            .as_any()
            .downcast_ref::<StringArray>()
            .expect("str column values buffer contains strings");
        let mut keys_builder = UInt16Array::builder(str_dict.len());
        for i in 0..str_dict.len() {
            if i % 10 == 0 {
                keys_builder.append_null();
            } else if str_dict.is_valid(i) {
                keys_builder.append_value(str_dict.keys().value(i));
            } else {
                keys_builder.append_null();
            }
        }
        let new_str_dict =
            DictionaryArray::<UInt16Type>::new(keys_builder.finish(), Arc::new(values.clone()));

        // replace the str column in attrs_batch
        let mut columns: Vec<Arc<dyn Array>> = attrs_batch.columns().to_vec();
        let str_col_idx = attrs_batch
            .schema()
            .index_of(consts::ATTRIBUTE_STR)
            .expect("contains str values");
        columns[str_col_idx] = Arc::new(new_str_dict);
        let new_attrs_batch =
            RecordBatch::try_new(attrs_batch.schema(), columns).expect("can create batch");
        otap_batch.set(ArrowPayloadType::LogAttrs, new_attrs_batch);
    }

    otap_batch
}

fn create_bench_batch(num_attrs: usize) -> RecordBatch {
    let mut types = UInt8Array::builder(num_attrs);
    let mut keys = StringBuilder::new();
    let mut str_values = StringBuilder::new();
    let mut int_values = Int64Array::builder(num_attrs);
    let mut double_values = Float64Array::builder(num_attrs);
    let mut bool_values = BooleanArray::builder(num_attrs);
    let mut parent_ids = UInt16Array::builder(num_attrs);

    // Distribute value types: 40% string, 30% int, 20% double, 10% bool
    let str_threshold = (num_attrs as f64 * 0.4) as usize;
    let int_threshold = (num_attrs as f64 * 0.7) as usize;
    let double_threshold = (num_attrs as f64 * 0.9) as usize;

    for i in 0..num_attrs {
        parent_ids.append_value(1);
        let attr_name = format!("attr{}", (i as f64 / 50.0) as usize);
        keys.append_value(attr_name);

        if i < str_threshold {
            types.append_value(AttributeValueType::Str as u8);
            int_values.append_null();
            bool_values.append_null();
            double_values.append_null();
            str_values.append_value(format!("str{}", (i as f64 / 10.0) as usize));
            continue;
        }

        if i < int_threshold {
            types.append_value(AttributeValueType::Int as u8);
            bool_values.append_null();
            double_values.append_null();
            str_values.append_null();
            int_values.append_value((i as f64 / 10.0) as i64);
            continue;
        }

        if i < double_threshold {
            types.append_value(AttributeValueType::Double as u8);
            bool_values.append_null();
            int_values.append_null();
            str_values.append_null();
            double_values.append_value((i as f64 / 10.0).floor());
            continue;
        }

        types.append_value(AttributeValueType::Bool as u8);
        str_values.append_null();
        int_values.append_null();
        double_values.append_null();
        bool_values.append_value(((i as f64 / 10.0) as usize).is_multiple_of(2));
    }

    let schema = Schema::new(vec![
        Field::new(consts::PARENT_ID, DataType::UInt16, false),
        Field::new(consts::ATTRIBUTE_KEY, DataType::Utf8, false),
        Field::new(consts::ATTRIBUTE_TYPE, DataType::UInt8, false),
        Field::new(consts::ATTRIBUTE_STR, DataType::Utf8, true),
        Field::new(consts::ATTRIBUTE_INT, DataType::Int64, true),
        Field::new(consts::ATTRIBUTE_DOUBLE, DataType::Float64, true),
        Field::new(consts::ATTRIBUTE_BOOL, DataType::Boolean, true),
    ]);

    RecordBatch::try_new(
        Arc::new(schema),
        vec![
            Arc::new(parent_ids.finish()),
            Arc::new(keys.finish()),
            Arc::new(types.finish()),
            Arc::new(str_values.finish()),
            Arc::new(int_values.finish()),
            Arc::new(double_values.finish()),
            Arc::new(bool_values.finish()),
        ],
    )
    .expect("expect can create this record batch")
}

fn bench_materialize_parent_ids(c: &mut Criterion) {
    let mut group = c.benchmark_group("materialize_parent_ids_for_attributes");

    for size in [0, 128, 1536, 8092] {
        let input = create_bench_batch(size);
        let _ = group.bench_with_input(
            BenchmarkId::new("materialize_parent_ids_for_attributes", size),
            &input,
            |b, input| {
                b.iter(|| {
                    let _ = materialize_parent_id_for_attributes::<u16>(input)
                        .expect("function should not error here");
                });
            },
        );
    }

    group.finish()
}

fn bench_encode_transport_optimized_ids(c: &mut Criterion) {
    let mut group = c.benchmark_group("encode_transport_optimized");
    for size in [127, 1536, 8096] {
        gen_fake_logs_batch(size);
        for with_nulls in [false, true] {
                let otap_batch = read_logs_batch(size, with_nulls);

                let bench_name = if with_nulls {
                    format!("encode_transport_optimized_ids_with_nulls/{}", size)
                } else {
                    format!("encode_transport_optimized_ids_no_nulls/{}", size)
                };

                let _ = group.bench_with_input(
                    BenchmarkId::from_parameter(bench_name),
                    &otap_batch,
                    |b, input| {
                        b.iter_batched(
                            || input.clone(),
                            |mut input| {
                                input.encode_transport_optimized().expect("can encode IDs");
                                black_box(input)
                            },
                            criterion::BatchSize::SmallInput,
                        );
                    },
                );
            }
    }
}

fn bench_decode_transport_optimized_ids(c: &mut Criterion) {
    let mut group = c.benchmark_group("decode_transport_optimized_ids");
    for size in [127, 1536, 8096] {
        gen_fake_logs_batch(size);
        for with_nulls in [false, true] {
            let mut otap_batch = read_logs_batch(size, with_nulls);
            otap_batch
                .encode_transport_optimized()
                .expect("can encode IDs");
            let bench_name = if with_nulls {
                format!("decode_transport_optimized_ids_with_nulls/{}", size)
            } else {
                format!("decode_transport_optimized_ids_no_nulls/{}", size)
            };

            let _ = group.bench_with_input(
                BenchmarkId::from_parameter(bench_name),
                &otap_batch,
                |b, input| {
                    b.iter_batched(
                        || input.clone(),
                        |mut input| {
                            input.decode_transport_optimized_ids().expect("decode");
                            black_box(input)
                        },
                        criterion::BatchSize::SmallInput,
                    );
                },
            );
        }
    }
}

#[allow(missing_docs)]
mod benches {
    use super::*;
    criterion_group!(
        name = benches;
        config = Criterion::default();
        targets = bench_materialize_parent_ids,
            bench_decode_transport_optimized_ids,
            bench_encode_transport_optimized_ids
    );
}

criterion_main!(benches::benches);
