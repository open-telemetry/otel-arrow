// Grammar for Observability Programming Language (OPL)

WHITESPACE = _{ " " | NEWLINE | "\t" }

ident = @{ ("_" | ASCII_ALPHA) ~ ("_" | ASCII_ALPHANUMERIC)* }

double_quote_string_char = _{
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
single_quote_string_char = _{
    !("'" | "\\") ~ ANY
    | "\\" ~ ("'" | "\\" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

string_literal = {
    ("\"" ~ double_quote_string_char* ~ "\"")
    | ("'" ~ single_quote_string_char* ~ "'")
}

identifier_expression = {
    ident
}

primitive_expression = {
    identifier_expression
    | string_literal
    | "true"
    | "false"
    | "null"
    // TODO there are more of these
}

member_expression = {
    // TODO there are more of these
    primitive_expression
}

integer_literal = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

exponent_literal = { ^"e" ~ ("+" | "-")? ~ integer_literal }
float_literal = @{
    (integer_literal ~ "." ~ integer_literal ~ exponent_literal?)
    | (integer_literal ~ exponent_literal)
}

number_literal = {
    integer_literal | float_literal
}

negate_token = @{ "-" }
not_token = @{ "not" }

unary_expression = {
    number_literal
    | "-" ~ number_literal
    // TODO negative unary?
    // | "-" ~ unary_expression
    | "not" ~ unary_expression
    | member_expression
}


multiplicative_op_mul = @{ "*" }
multiplicative_op_div = @{ "/" }
multiplicative_op_mod = @{ "%" }
multiplicative_op = {
    multiplicative_op_mod | multiplicative_op_div | multiplicative_op_mod
}

multiplicative_expression = {
    unary_expression ~ (multiplicative_op ~ multiplicative_expression)*
}

additive_op_add = @{ "+" }
additive_op_sub = @{ "-" }
additive_op = {
    additive_op_add | additive_op_sub
}

additive_expression = {
    multiplicative_expression ~ (additive_op ~ additive_expression)*
}


rel_op_eq = @{ "==" }
rel_op_neq = @{ "!="}
rel_op = {
    rel_op_eq | rel_op_neq
}

rel_expression = {
    additive_expression ~ (rel_op ~ rel_expression)*
}

// TODO add bitwise expressions

and_expression = {
    rel_expression ~ ("and" ~ and_expression)*
}

or_expression = {
    and_expression ~ ("or" ~ or_expression)*
}

expression = {
    or_expression
}

// TODO add other sources
source = {
    "logs"
}

where_operator_call = {
    "where" ~ expression
}

operator_call = {
    where_operator_call
}

pipeline_stage = {
    operator_call
}

pipeline = {
    source ~ ("|" ~ pipeline_stage)+
}

program = {
    SOI ~ pipeline ~ EOI
}