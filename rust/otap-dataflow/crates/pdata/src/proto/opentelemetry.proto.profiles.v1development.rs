// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfilesData {
    #[prost(message, repeated, tag="1")]
    pub resource_profiles: ::prost::alloc::vec::Vec<ResourceProfiles>,
    #[prost(message, repeated, tag="2")]
    pub mapping_table: ::prost::alloc::vec::Vec<Mapping>,
    #[prost(message, repeated, tag="3")]
    pub location_table: ::prost::alloc::vec::Vec<Location>,
    #[prost(message, repeated, tag="4")]
    pub function_table: ::prost::alloc::vec::Vec<Function>,
    #[prost(message, repeated, tag="5")]
    pub link_table: ::prost::alloc::vec::Vec<Link>,
    #[prost(string, repeated, tag="6")]
    pub string_table: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="7")]
    pub attribute_table: ::prost::alloc::vec::Vec<super::super::common::v1::KeyValue>,
    #[prost(message, repeated, tag="8")]
    pub attribute_units: ::prost::alloc::vec::Vec<AttributeUnit>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceProfiles {
    #[prost(message, optional, tag="1")]
    pub resource: ::core::option::Option<super::super::resource::v1::Resource>,
    #[prost(message, repeated, tag="2")]
    pub scope_profiles: ::prost::alloc::vec::Vec<ScopeProfiles>,
    #[prost(string, tag="3")]
    pub schema_url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScopeProfiles {
    #[prost(message, optional, tag="1")]
    pub scope: ::core::option::Option<super::super::common::v1::InstrumentationScope>,
    #[prost(message, repeated, tag="2")]
    pub profiles: ::prost::alloc::vec::Vec<Profile>,
    #[prost(string, tag="3")]
    pub schema_url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(message, repeated, tag="1")]
    pub sample_type: ::prost::alloc::vec::Vec<ValueType>,
    #[prost(message, repeated, tag="2")]
    pub sample: ::prost::alloc::vec::Vec<Sample>,
    #[prost(int32, repeated, tag="3")]
    pub location_indices: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, tag="4")]
    pub time_nanos: i64,
    #[prost(int64, tag="5")]
    pub duration_nanos: i64,
    #[prost(message, optional, tag="6")]
    pub period_type: ::core::option::Option<ValueType>,
    #[prost(int64, tag="7")]
    pub period: i64,
    #[prost(int32, repeated, tag="8")]
    pub comment_strindices: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, tag="9")]
    pub default_sample_type_index: i32,
    #[prost(bytes="vec", tag="10")]
    pub profile_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag="11")]
    pub dropped_attributes_count: u32,
    #[prost(string, tag="12")]
    pub original_payload_format: ::prost::alloc::string::String,
    #[prost(bytes="vec", tag="13")]
    pub original_payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, repeated, tag="14")]
    pub attribute_indices: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttributeUnit {
    #[prost(int32, tag="1")]
    pub attribute_key_strindex: i32,
    #[prost(int32, tag="2")]
    pub unit_strindex: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Link {
    #[prost(bytes="vec", tag="1")]
    pub trace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes="vec", tag="2")]
    pub span_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValueType {
    #[prost(int32, tag="1")]
    pub type_strindex: i32,
    #[prost(int32, tag="2")]
    pub unit_strindex: i32,
    #[prost(enumeration="AggregationTemporality", tag="3")]
    pub aggregation_temporality: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Sample {
    #[prost(int32, tag="1")]
    pub locations_start_index: i32,
    #[prost(int32, tag="2")]
    pub locations_length: i32,
    #[prost(int64, repeated, tag="3")]
    pub value: ::prost::alloc::vec::Vec<i64>,
    #[prost(int32, repeated, tag="4")]
    pub attribute_indices: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag="5")]
    pub link_index: ::core::option::Option<i32>,
    #[prost(uint64, repeated, tag="6")]
    pub timestamps_unix_nano: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Mapping {
    #[prost(uint64, tag="1")]
    pub memory_start: u64,
    #[prost(uint64, tag="2")]
    pub memory_limit: u64,
    #[prost(uint64, tag="3")]
    pub file_offset: u64,
    #[prost(int32, tag="4")]
    pub filename_strindex: i32,
    #[prost(int32, repeated, tag="5")]
    pub attribute_indices: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag="6")]
    pub has_functions: bool,
    #[prost(bool, tag="7")]
    pub has_filenames: bool,
    #[prost(bool, tag="8")]
    pub has_line_numbers: bool,
    #[prost(bool, tag="9")]
    pub has_inline_frames: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Location {
    #[prost(int32, optional, tag="1")]
    pub mapping_index: ::core::option::Option<i32>,
    #[prost(uint64, tag="2")]
    pub address: u64,
    #[prost(message, repeated, tag="3")]
    pub line: ::prost::alloc::vec::Vec<Line>,
    #[prost(bool, tag="4")]
    pub is_folded: bool,
    #[prost(int32, repeated, tag="5")]
    pub attribute_indices: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Line {
    #[prost(int32, tag="1")]
    pub function_index: i32,
    #[prost(int64, tag="2")]
    pub line: i64,
    #[prost(int64, tag="3")]
    pub column: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Function {
    #[prost(int32, tag="1")]
    pub name_strindex: i32,
    #[prost(int32, tag="2")]
    pub system_name_strindex: i32,
    #[prost(int32, tag="3")]
    pub filename_strindex: i32,
    #[prost(int64, tag="4")]
    pub start_line: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationTemporality {
    Unspecified = 0,
    Delta = 1,
    Cumulative = 2,
}
impl AggregationTemporality {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AGGREGATION_TEMPORALITY_UNSPECIFIED",
            Self::Delta => "AGGREGATION_TEMPORALITY_DELTA",
            Self::Cumulative => "AGGREGATION_TEMPORALITY_CUMULATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATION_TEMPORALITY_UNSPECIFIED" => Some(Self::Unspecified),
            "AGGREGATION_TEMPORALITY_DELTA" => Some(Self::Delta),
            "AGGREGATION_TEMPORALITY_CUMULATIVE" => Some(Self::Cumulative),
            _ => None,
        }
    }
}
