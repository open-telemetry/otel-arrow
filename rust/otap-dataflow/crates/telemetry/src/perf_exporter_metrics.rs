// SPDX-License-Identifier: Apache-2.0

//! Multivariate metrics for the Perf Exporter

use crate::{Counter, Metrics, MetricsKind, MetricsDescriptor, MetricsField, MetricsTypeId};

/// Multivariate metrics for the OTAP PerfExporter node.
///
/// Note: This struct and its implementation will be generated by OTEL Weaver in the future.
#[repr(C, align(64))]
pub struct PerfExporterMetrics {
    /// Total bytes processed by the perf exporter.
    pub bytes_total: Counter<u64>,
    /// Number of pdata messages handled.
    pub pdata_msgs: Counter<u64>,
    /// Number of logs processed.
    pub logs: Counter<u64>,
    /// Number of spans processed.
    pub spans: Counter<u64>,
    /// Number of metrics processed.
    pub metrics: Counter<u64>,
}

impl PerfExporterMetrics {
    /// Creates a new zero-initialized perf exporter metrics struct.
    pub fn new() -> Self {
        Self {
            bytes_total: Counter::new(0),
            pdata_msgs: Counter::new(0),
            logs: Counter::new(0),
            spans: Counter::new(0),
            metrics: Counter::new(0),
        }
    }
}

const METRIC_SET: &[MetricsField] = &[
    MetricsField {
        name: "bytes.total",
        unit: "bytes",
        kind: MetricsKind::Counter,
    },
    MetricsField {
        name: "pdata.messages",
        unit: "count",
        kind: MetricsKind::Counter,
    },
    MetricsField {
        name: "logs",
        unit: "count",
        kind: MetricsKind::Counter,
    },
    MetricsField {
        name: "spans",
        unit: "count",
        kind: MetricsKind::Counter,
    },
    MetricsField {
        name: "metrics",
        unit: "count",
        kind: MetricsKind::Counter,
    },
];

const MULTIVARIATE_METRICS: MetricsDescriptor = MetricsDescriptor {
    struct_name: "PerfExporterMetrics",
    name: "otap_perf_exporter",
    fields: METRIC_SET,
};

impl Metrics for PerfExporterMetrics {
    fn descriptor() -> &'static MetricsDescriptor {
        &MULTIVARIATE_METRICS
    }
    fn type_id() -> MetricsTypeId {
        MetricsTypeId::of::<Self>()
    }
    fn zero(&mut self) {
        // ToDo - consider using an unsafe zeroing method for performance
        self.bytes_total.set(0);
        self.pdata_msgs.set(0);
        self.logs.set(0);
        self.spans.set(0);
        self.metrics.set(0);
    }
    fn copy_to_bytes(&self, _dst: &mut [u8]) {}
    fn from_bytes(_src: &[u8]) -> Self {
        Self::new()
    }
    fn visit<F: FnMut(&MetricsField, u64)>(&self, mut f: F) {
        let d = Self::descriptor();
        f(&d.fields[0], self.bytes_total.get());
        f(&d.fields[1], self.pdata_msgs.get());
        f(&d.fields[2], self.logs.get());
        f(&d.fields[3], self.spans.get());
        f(&d.fields[4], self.metrics.get());
    }
}

#[cfg(test)]
mod tests {
    use crate::perf_exporter_metrics::PerfExporterMetrics;
    use crate::{NodeMetricsHandle, Registry, SimpleCollector, SpscQueue};

    #[test]
    fn perf_exporter_metrics_collection() {
        let q = SpscQueue::with_capacity_pow2(8);
        let (prod, cons) = q.split();
        let reg = Registry::global().clone();
        let mut handle = NodeMetricsHandle::new(42, PerfExporterMetrics::new());
        handle.metrics.bytes_total.add(1024);
        handle.metrics.pdata_msgs.add(8);
        handle.metrics.logs.add(3);
        handle.metrics.spans.add(5);
        handle.metrics.metrics.add(2);
        prod.push(handle.flush_snapshot()).unwrap();
        let collector = SimpleCollector::new(cons, &reg);
        let results = collector.drain();
        assert_eq!(results.len(), 5);
        // bytes is field 0
        let bytes_total = results.iter().find(|((_, idx), _)| *idx == 0).unwrap().1;
        assert_eq!(bytes_total, 1024);
    }
}
