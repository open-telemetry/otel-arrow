diff --git a/rust/otap-dataflow/crates/pdata/src/error.rs b/rust/otap-dataflow/crates/pdata/src/error.rs
index 88540081..c30b804a 100644
--- a/rust/otap-dataflow/crates/pdata/src/error.rs
+++ b/rust/otap-dataflow/crates/pdata/src/error.rs
@@ -15,6 +15,24 @@ use std::num::TryFromIntError;
 /// Result type
 pub type Result<T> = std::result::Result<T, Error>;
 
+/// Error indicating that a fixed-size buffer ran out of space during encoding.
+///
+/// This error is returned by [`ProtoWrite`] implementations when there is
+/// insufficient capacity to complete an encoding operation. For fixed-size
+/// buffers used in internal instrumentation, callers can catch this error
+/// and use the partially-encoded contents, incrementing a dropped-attributes
+/// counter instead.
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub struct Truncated;
+
+impl std::fmt::Display for Truncated {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(f, "buffer truncated: insufficient capacity for encoding")
+    }
+}
+
+impl std::error::Error for Truncated {}
+
 /// Errors related to OTAP or OTLP pipeline data
 #[derive(thiserror::Error, Debug)]
 #[allow(missing_docs)]
@@ -179,4 +197,7 @@ pub enum Error {
 
     #[error("Format error: {}", error)]
     Format { error: String },
+
+    #[error("Buffer truncated: insufficient capacity for encoding")]
+    Truncated(#[from] Truncated),
 }
diff --git a/rust/otap-dataflow/crates/pdata/src/otlp/common.rs b/rust/otap-dataflow/crates/pdata/src/otlp/common.rs
index e3a0859d..f1536aef 100644
--- a/rust/otap-dataflow/crates/pdata/src/otlp/common.rs
+++ b/rust/otap-dataflow/crates/pdata/src/otlp/common.rs
@@ -5,7 +5,7 @@ use crate::arrays::{
     ByteArrayAccessor, Int64ArrayAccessor, MaybeDictArrayAccessor, NullableArrayAccessor,
     StringArrayAccessor, StructColumnAccessor, get_bool_array_opt, get_f64_array_opt, get_u8_array,
 };
-use crate::error::{Error, Result};
+use crate::error::{Error, Result, Truncated};
 use crate::otlp::attributes::{Attribute16Arrays, encode_key_value};
 use crate::proto::consts::field_num::common::{
     INSTRUMENTATION_DROPPED_ATTRIBUTES_COUNT, INSTRUMENTATION_SCOPE_ATTRIBUTES,
@@ -30,6 +30,216 @@ use std::fmt;
 use std::fmt::Write;
 use std::sync::LazyLock;
 
+/// Trait for types that can be used as protobuf encoding buffers.
+///
+/// This trait abstracts over growable buffers (like [`ProtoBuffer`]) and fixed-size
+/// buffers (like [`FixedProtoBuffer`]), allowing encoding logic to work with both.
+///
+/// For fixed-size buffers, operations return `Err(Truncated)` when there is
+/// insufficient capacity. Callers can catch this error and use the partially-encoded
+/// contents, for example by incrementing a dropped-attributes counter.
+///
+/// # Example
+///
+/// ```ignore
+/// fn encode_attributes<W: ProtoWrite>(buf: &mut W, attrs: &[KeyValue]) -> Result<(), Truncated> {
+///     for attr in attrs {
+///         buf.encode_string(ATTR_KEY_TAG, &attr.key)?;
+///         buf.encode_string(ATTR_VALUE_TAG, &attr.value)?;
+///     }
+///     Ok(())
+/// }
+/// ```
+pub trait ProtoWrite {
+    /// Append bytes to the buffer.
+    ///
+    /// Returns `Err(Truncated)` if there is insufficient capacity (for fixed-size buffers).
+    fn write_bytes(&mut self, bytes: &[u8]) -> std::result::Result<(), Truncated>;
+
+    /// Current length of encoded data.
+    fn len(&self) -> usize;
+
+    /// Returns true if the buffer is empty.
+    fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    /// Get a reference to the encoded bytes.
+    fn as_slice(&self) -> &[u8];
+
+    /// Get a mutable reference to the buffer (for patching length placeholders).
+    fn as_mut_slice(&mut self) -> &mut [u8];
+
+    /// Clear the buffer contents.
+    fn clear(&mut self);
+
+    /// Current capacity of the buffer.
+    fn capacity(&self) -> usize;
+
+    /// Remaining capacity available for writing.
+    fn remaining(&self) -> usize {
+        self.capacity().saturating_sub(self.len())
+    }
+
+    /// Push a single byte.
+    #[inline]
+    fn write_byte(&mut self, byte: u8) -> std::result::Result<(), Truncated> {
+        self.write_bytes(&[byte])
+    }
+
+    /// Encode a varint (variable-length integer).
+    #[inline]
+    fn encode_varint(&mut self, value: u64) -> std::result::Result<(), Truncated> {
+        // Fast path for single byte (very common)
+        if value < 0x80 {
+            return self.write_byte(value as u8);
+        }
+
+        // Fast path for two bytes (common)
+        if value < 0x4000 {
+            return self.write_bytes(&[((value & 0x7F) | 0x80) as u8, (value >> 7) as u8]);
+        }
+
+        // General case
+        let mut v = value;
+        while v >= 0x80 {
+            self.write_byte(((v & 0x7F) | 0x80) as u8)?;
+            v >>= 7;
+        }
+        self.write_byte(v as u8)
+    }
+
+    /// Encode a protobuf field tag (field number + wire type).
+    #[inline]
+    fn encode_field_tag(
+        &mut self,
+        field_number: u64,
+        wire_type: u64,
+    ) -> std::result::Result<(), Truncated> {
+        let key = (field_number << 3) | wire_type;
+        self.encode_varint(key)
+    }
+
+    /// Encode a signed varint using zig-zag encoding (sint32/sint64).
+    #[inline]
+    fn encode_sint32(&mut self, value: i32) -> std::result::Result<(), Truncated> {
+        self.encode_varint(((value << 1) ^ (value >> 31)) as u64)
+    }
+
+    /// Encode a length-delimited string field.
+    fn encode_string(&mut self, field_tag: u64, val: &str) -> std::result::Result<(), Truncated> {
+        self.encode_field_tag(field_tag, wire_types::LEN)?;
+        self.encode_varint(val.len() as u64)?;
+        self.write_bytes(val.as_bytes())
+    }
+
+    /// Encode a length-delimited bytes field.
+    fn encode_bytes_field(
+        &mut self,
+        field_tag: u64,
+        val: &[u8],
+    ) -> std::result::Result<(), Truncated> {
+        self.encode_field_tag(field_tag, wire_types::LEN)?;
+        self.encode_varint(val.len() as u64)?;
+        self.write_bytes(val)
+    }
+}
+
+/// A fixed-size, stack-allocatable buffer for protobuf encoding.
+///
+/// This buffer is designed for internal instrumentation where heap allocation
+/// should be avoided. When the buffer runs out of space, encoding operations
+/// return `Err(Truncated)`, allowing callers to use the partial contents and
+/// track dropped attributes.
+///
+/// # Example
+///
+/// ```ignore
+/// let mut buf = FixedProtoBuffer::<1024>::new();
+/// match encode_log_record(&mut buf, &record) {
+///     Ok(()) => send_proto_bytes(buf.as_slice()),
+///     Err(Truncated) => {
+///         // Use partial contents, increment dropped counter
+///         dropped_count += 1;
+///         send_proto_bytes(buf.as_slice());
+///     }
+/// }
+/// ```
+#[derive(Debug)]
+pub struct FixedProtoBuffer<const N: usize> {
+    buffer: [u8; N],
+    len: usize,
+}
+
+impl<const N: usize> Default for FixedProtoBuffer<N> {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+impl<const N: usize> FixedProtoBuffer<N> {
+    /// Create a new empty fixed-size buffer.
+    #[must_use]
+    pub const fn new() -> Self {
+        Self {
+            buffer: [0u8; N],
+            len: 0,
+        }
+    }
+
+    /// Returns the maximum capacity of this buffer.
+    #[must_use]
+    pub const fn max_capacity() -> usize {
+        N
+    }
+}
+
+impl<const N: usize> ProtoWrite for FixedProtoBuffer<N> {
+    #[inline]
+    fn write_bytes(&mut self, bytes: &[u8]) -> std::result::Result<(), Truncated> {
+        let new_len = self.len.checked_add(bytes.len()).ok_or(Truncated)?;
+        if new_len > N {
+            return Err(Truncated);
+        }
+        self.buffer[self.len..new_len].copy_from_slice(bytes);
+        self.len = new_len;
+        Ok(())
+    }
+
+    #[inline]
+    fn len(&self) -> usize {
+        self.len
+    }
+
+    fn as_slice(&self) -> &[u8] {
+        &self.buffer[..self.len]
+    }
+
+    fn as_mut_slice(&mut self) -> &mut [u8] {
+        &mut self.buffer[..self.len]
+    }
+
+    fn clear(&mut self) {
+        self.len = 0;
+    }
+
+    fn capacity(&self) -> usize {
+        N
+    }
+}
+
+impl<const N: usize> AsRef<[u8]> for FixedProtoBuffer<N> {
+    fn as_ref(&self) -> &[u8] {
+        self.as_slice()
+    }
+}
+
+impl<const N: usize> AsMut<[u8]> for FixedProtoBuffer<N> {
+    fn as_mut(&mut self) -> &mut [u8] {
+        self.as_mut_slice()
+    }
+}
+
 pub(in crate::otlp) struct ResourceArrays<'a> {
     pub id: Option<&'a UInt16Array>,
     pub dropped_attributes_count: Option<&'a UInt32Array>,
@@ -451,6 +661,35 @@ impl AsMut<[u8]> for ProtoBuffer {
     }
 }
 
+impl ProtoWrite for ProtoBuffer {
+    #[inline]
+    fn write_bytes(&mut self, bytes: &[u8]) -> std::result::Result<(), Truncated> {
+        self.buffer.extend_from_slice(bytes);
+        Ok(())
+    }
+
+    #[inline]
+    fn len(&self) -> usize {
+        self.buffer.len()
+    }
+
+    fn as_slice(&self) -> &[u8] {
+        &self.buffer
+    }
+
+    fn as_mut_slice(&mut self) -> &mut [u8] {
+        &mut self.buffer
+    }
+
+    fn clear(&mut self) {
+        self.buffer.clear();
+    }
+
+    fn capacity(&self) -> usize {
+        self.buffer.capacity()
+    }
+}
+
 /// Helper for encoding with unknown length. Usage:
 /// ```ignore
 /// proto_encode_len_delimited_unknown_size!(
@@ -478,24 +717,52 @@ impl AsMut<[u8]> for ProtoBuffer {
 /// TODO: currently we're always allocating 4 byte. This may often be too much but we over-allocate
 /// to be safe. Eventually we should maybe allow a size hint here and allocate fewer bytes.
 ///
+/// # Note on buffer types
+///
+/// This macro works with [`ProtoBuffer`] (the growable Vec-based buffer) and uses infallible
+/// operations. For use with [`FixedProtoBuffer`] or other [`ProtoWrite`] implementations
+/// that may return [`Truncated`] errors, use [`proto_encode_len_delimited_try!`] instead.
 #[macro_export]
 macro_rules! proto_encode_len_delimited_unknown_size {
     ($field_tag: expr, $encode_fn:expr, $buf:expr) => {{
         let num_bytes = 4; // placeholder length
         $buf.encode_field_tag($field_tag, $crate::proto::consts::wire_types::LEN);
         let len_start_pos = $buf.len();
-        $crate::otlp::common::encode_len_placeholder($buf);
+        $crate::otlp::common::encode_len_placeholder_infallible($buf);
         $encode_fn;
         let len = $buf.len() - len_start_pos - num_bytes;
-        $crate::otlp::common::patch_len_placeholder($buf, num_bytes, len, len_start_pos);
+        $crate::otlp::common::patch_len_placeholder_infallible($buf, num_bytes, len, len_start_pos);
     }};
 }
 
-pub(crate) fn encode_len_placeholder(buf: &mut ProtoBuffer) {
+pub(crate) fn encode_len_placeholder<W: ProtoWrite>(
+    buf: &mut W,
+) -> std::result::Result<(), Truncated> {
+    buf.write_bytes(&[0x80, 0x80, 0x80, 0x00])
+}
+
+pub(crate) fn patch_len_placeholder<W: ProtoWrite>(
+    buf: &mut W,
+    num_bytes: usize,
+    len: usize,
+    len_start_pos: usize,
+) {
+    let slice = buf.as_mut_slice();
+    for i in 0..num_bytes {
+        slice[len_start_pos + i] += ((len >> (i * 7)) & 0x7f) as u8;
+    }
+}
+
+/// Infallible version of [`encode_len_placeholder`] for use with [`ProtoBuffer`].
+///
+/// This function directly extends the buffer without returning a Result,
+/// for use in the infallible encoding path with growable buffers.
+pub(crate) fn encode_len_placeholder_infallible(buf: &mut ProtoBuffer) {
     buf.buffer.extend_from_slice(&[0x80, 0x80, 0x80, 0x00]);
 }
 
-pub(crate) fn patch_len_placeholder(
+/// Infallible version of [`patch_len_placeholder`] for use with [`ProtoBuffer`].
+pub(crate) fn patch_len_placeholder_infallible(
     buf: &mut ProtoBuffer,
     num_bytes: usize,
     len: usize,
@@ -506,6 +773,41 @@ pub(crate) fn patch_len_placeholder(
     }
 }
 
+/// Fallible helper macro for encoding with unknown length, for use with any [`ProtoWrite`] impl.
+///
+/// Unlike [`proto_encode_len_delimited_unknown_size!`], this macro propagates truncation errors
+/// and is intended for use with fixed-size buffers or generic code that works with any
+/// [`ProtoWrite`] implementation.
+///
+/// The enclosing function must return a `Result` type that can convert from [`Truncated`].
+///
+/// # Example
+///
+/// ```ignore
+/// fn encode_message<W: ProtoWrite>(buf: &mut W) -> Result<(), Truncated> {
+///     proto_encode_len_delimited_try!(
+///         FIELD_TAG,
+///         encode_nested_content(buf)?,
+///         buf
+///     )?;
+///     Ok(())
+/// }
+/// ```
+#[macro_export]
+macro_rules! proto_encode_len_delimited_try {
+    ($field_tag: expr, $encode_fn:expr, $buf:expr) => {{
+        use $crate::otlp::ProtoWrite;
+        let num_bytes = 4; // placeholder length
+        $buf.encode_field_tag($field_tag, $crate::proto::consts::wire_types::LEN)?;
+        let len_start_pos = $buf.len();
+        $crate::otlp::common::encode_len_placeholder($buf)?;
+        $encode_fn;
+        let len = $buf.len() - len_start_pos - num_bytes;
+        $crate::otlp::common::patch_len_placeholder($buf, num_bytes, len, len_start_pos);
+        Ok::<(), $crate::error::Truncated>(())
+    }};
+}
+
 /// Used to iterate over OTAP [`RecordBatch`] in a particular order.
 ///
 /// There are certain use cases where we want to visit all the rows in some record batch that are
@@ -1132,4 +1434,201 @@ mod test {
     fn test_metrics_with_no_metrics() {
         assert_empty_batch(metrics_with_no_metrics().into());
     }
+
+    //
+    // ProtoWrite and FixedProtoBuffer tests
+    //
+
+    use super::{FixedProtoBuffer, ProtoBuffer, ProtoWrite};
+    use crate::error::Truncated;
+
+    #[test]
+    fn test_proto_buffer_implements_proto_write() {
+        let mut buf = ProtoBuffer::new();
+
+        // Test basic write operations via the trait (using fully qualified syntax)
+        ProtoWrite::write_bytes(&mut buf, b"hello").unwrap();
+        assert_eq!(ProtoWrite::len(&buf), 5);
+        assert_eq!(ProtoWrite::as_slice(&buf), b"hello");
+
+        // Test varint encoding via trait
+        ProtoWrite::clear(&mut buf);
+        ProtoWrite::encode_varint(&mut buf, 127).unwrap(); // single byte
+        assert_eq!(buf.len(), 1);
+        assert_eq!(ProtoWrite::as_slice(&buf), &[127]);
+
+        ProtoWrite::clear(&mut buf);
+        ProtoWrite::encode_varint(&mut buf, 128).unwrap(); // two bytes
+        assert_eq!(buf.len(), 2);
+
+        ProtoWrite::clear(&mut buf);
+        ProtoWrite::encode_varint(&mut buf, 16384).unwrap(); // three bytes
+        assert_eq!(buf.len(), 3);
+
+        // Test string encoding via trait
+        ProtoWrite::clear(&mut buf);
+        ProtoWrite::encode_string(&mut buf, 1, "test").unwrap();
+        assert!(buf.len() > 4); // tag + length + "test"
+    }
+
+    #[test]
+    fn test_proto_buffer_inherent_methods_unchanged() {
+        // Verify that the original infallible API still works
+        let mut buf = ProtoBuffer::new();
+
+        // These are the inherent methods (infallible, no Result)
+        buf.encode_varint(127);
+        assert_eq!(buf.len(), 1);
+
+        buf.clear();
+        buf.encode_string(1, "test");
+        assert!(buf.len() > 4);
+
+        buf.clear();
+        buf.extend_from_slice(b"direct");
+        assert_eq!(buf.as_ref(), b"direct");
+    }
+
+    #[test]
+    fn test_fixed_proto_buffer_basic() {
+        let mut buf = FixedProtoBuffer::<64>::new();
+
+        assert_eq!(buf.len(), 0);
+        assert_eq!(buf.capacity(), 64);
+        assert_eq!(buf.remaining(), 64);
+
+        // Write some bytes
+        buf.write_bytes(b"hello").unwrap();
+        assert_eq!(buf.len(), 5);
+        assert_eq!(buf.remaining(), 59);
+        assert_eq!(buf.as_slice(), b"hello");
+
+        // Clear and verify
+        buf.clear();
+        assert_eq!(buf.len(), 0);
+        assert_eq!(buf.remaining(), 64);
+    }
+
+    #[test]
+    fn test_fixed_proto_buffer_truncation() {
+        let mut buf = FixedProtoBuffer::<10>::new();
+
+        // Write should succeed when under capacity
+        assert!(buf.write_bytes(b"12345").is_ok());
+        assert_eq!(buf.len(), 5);
+
+        // Write should succeed when exactly at capacity
+        assert!(buf.write_bytes(b"67890").is_ok());
+        assert_eq!(buf.len(), 10);
+
+        // Write should fail when over capacity
+        let result = buf.write_bytes(b"x");
+        assert_eq!(result, Err(Truncated));
+
+        // Buffer contents should be unchanged after failed write
+        assert_eq!(buf.len(), 10);
+        assert_eq!(buf.as_slice(), b"1234567890");
+    }
+
+    #[test]
+    fn test_fixed_proto_buffer_varint_truncation() {
+        // Create a buffer that can only hold 1 byte
+        let mut buf = FixedProtoBuffer::<1>::new();
+
+        // Small varint (1 byte) should succeed
+        assert!(buf.encode_varint(127).is_ok());
+        assert_eq!(buf.len(), 1);
+
+        // Clear and try a larger varint that needs 2 bytes
+        buf.clear();
+        let result = buf.encode_varint(128);
+        assert_eq!(result, Err(Truncated));
+
+        // For the 2-byte fast path, write_bytes checks capacity atomically,
+        // so no partial write occurs (the buffer remains empty)
+        assert_eq!(buf.len(), 0);
+
+        // Test partial write in the general case (3+ byte varints)
+        let mut buf3 = FixedProtoBuffer::<2>::new();
+        // Value 16384 needs 3 bytes in varint encoding
+        let result = buf3.encode_varint(16384);
+        assert_eq!(result, Err(Truncated));
+        // The general case writes byte-by-byte, so partial writes can occur
+        assert_eq!(buf3.len(), 2); // two bytes written before failure
+    }
+
+    #[test]
+    fn test_fixed_proto_buffer_encode_string_truncation() {
+        // Create a small buffer
+        let mut buf = FixedProtoBuffer::<8>::new();
+
+        // This should fail because the string + tag + length is > 8 bytes
+        let result = buf.encode_string(1, "hello world");
+        assert_eq!(result, Err(Truncated));
+
+        // Partial contents are in the buffer (useful for truncation recovery)
+        assert!(buf.len() > 0);
+    }
+
+    #[test]
+    fn test_proto_write_trait_generic_function() {
+        // Demonstrate using a generic function over ProtoWrite
+        fn encode_test_message<W: ProtoWrite>(
+            buf: &mut W,
+            value: u64,
+        ) -> Result<(), Truncated> {
+            buf.encode_field_tag(1, 0)?; // varint wire type
+            buf.encode_varint(value)?;
+            Ok(())
+        }
+
+        // Works with ProtoBuffer (growable)
+        let mut growing_buf = ProtoBuffer::new();
+        encode_test_message(&mut growing_buf, 12345).unwrap();
+        assert!(growing_buf.len() > 0);
+
+        // Works with FixedProtoBuffer
+        let mut fixed_buf = FixedProtoBuffer::<32>::new();
+        encode_test_message(&mut fixed_buf, 12345).unwrap();
+        assert_eq!(fixed_buf.as_slice(), growing_buf.as_slice());
+
+        // Fixed buffer can fail
+        let mut tiny_buf = FixedProtoBuffer::<2>::new();
+        let result = encode_test_message(&mut tiny_buf, 12345);
+        assert_eq!(result, Err(Truncated));
+    }
+
+    #[test]
+    fn test_fixed_proto_buffer_partial_content_on_truncation() {
+        // This test demonstrates the truncation recovery pattern:
+        // encode as much as possible, then on truncation, use partial content
+
+        let mut buf = FixedProtoBuffer::<20>::new();
+
+        // Simulate encoding multiple attributes
+        let attrs = [("a", "1"), ("b", "2"), ("c", "very long value that won't fit")];
+        let mut encoded_count = 0;
+
+        for (key, val) in &attrs {
+            // Try to encode the key-value pair
+            let start_len = buf.len();
+            if buf.encode_string(1, key).is_err() {
+                break;
+            }
+            if buf.encode_string(2, val).is_err() {
+                // Failed to encode value, could truncate here
+                // For this test, we just break
+                break;
+            }
+            encoded_count += 1;
+            let _ = start_len; // silence unused warning
+        }
+
+        // We should have encoded at least some attributes
+        assert!(encoded_count >= 1);
+        assert!(encoded_count < attrs.len()); // but not all due to truncation
+
+        // The buffer contains the partial encoding
+        assert!(buf.len() > 0);
+    }
 }
diff --git a/rust/otap-dataflow/crates/pdata/src/otlp/mod.rs b/rust/otap-dataflow/crates/pdata/src/otlp/mod.rs
index f4f4056c..d731e401 100644
--- a/rust/otap-dataflow/crates/pdata/src/otlp/mod.rs
+++ b/rust/otap-dataflow/crates/pdata/src/otlp/mod.rs
@@ -9,10 +9,15 @@ use crate::{error::Result, otap::OtapArrowRecords};
 use bytes::Bytes;
 use otap_df_config::SignalType;
 
+pub use common::FixedProtoBuffer;
 pub use common::ProtoBuffer;
+pub use common::ProtoWrite;
 pub use otap_df_pdata_otlp_macros::Message; // Required for derived code
 pub use otap_df_pdata_otlp_macros::qualified; // Required for derived code
 
+// Re-export Truncated from error module for convenience
+pub use crate::error::Truncated;
+
 /// Common methods for OTLP/OTAP attributes.
 pub mod attributes;
 /// Common methods for batching.
