//! Integration tests for mTLS functionality.

// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

#![cfg(feature = "experimental-tls")]

use otap_df_config::tls::{TlsConfig, TlsServerConfig};
use otap_df_otap::tls_utils::build_reloadable_server_config;
use rcgen::{BasicConstraints, CertificateParams, DnType, IsCa, KeyPair};
use rustls_pki_types::pem::PemObject;
use rustls_pki_types::{CertificateDer, PrivateKeyDer};
use std::fs;
use std::io;
use std::sync::Arc;
use tempfile::TempDir;

/// Certificate and key pair generated by rcgen.
struct GeneratedCert {
    cert_pem: String,
    key_pem: String,
}

/// Generate a self-signed certificate using rcgen.
///
/// # Arguments
/// * `cn` - Common Name for the certificate
/// * `san` - Optional Subject Alternative Name (DNS name)
/// * `is_ca` - Whether this is a CA certificate
fn generate_cert(cn: &str, san: Option<&str>, is_ca: bool) -> GeneratedCert {
    let mut params = if let Some(san_name) = san {
        CertificateParams::new(vec![san_name.to_string()]).expect("Invalid SAN")
    } else {
        CertificateParams::default()
    };

    params.distinguished_name.push(DnType::CommonName, cn);

    if is_ca {
        params.is_ca = IsCa::Ca(BasicConstraints::Unconstrained);
    } else {
        params.is_ca = IsCa::ExplicitNoCa;
    }

    let key_pair = KeyPair::generate().expect("Failed to generate key pair");
    let cert = params
        .self_signed(&key_pair)
        .expect("Failed to self-sign certificate");

    GeneratedCert {
        cert_pem: cert.pem(),
        key_pem: key_pair.serialize_pem(),
    }
}

#[tokio::test]
async fn test_mtls_client_cert_verification() {
    let _ = rustls::crypto::ring::default_provider().install_default();

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let path = temp_dir.path();

    // 1. Generate self-signed client certificate (used directly for trust verification)
    let client_cert = generate_cert("Test Client", None, false);
    let client_cert_path = path.join("client.crt");
    let client_key_path = path.join("client.key");
    fs::write(&client_cert_path, &client_cert.cert_pem).expect("Write client cert");
    fs::write(&client_key_path, &client_cert.key_pem).expect("Write client key");

    // Server Cert (self-signed)
    let server_cert = generate_cert("localhost", Some("localhost"), false);
    let server_cert_path = path.join("server.crt");
    let server_key_path = path.join("server.key");
    fs::write(&server_cert_path, &server_cert.cert_pem).expect("Write server cert");
    fs::write(&server_key_path, &server_cert.key_pem).expect("Write server key");

    // 3. Configure Server to trust Client Cert
    let config = TlsServerConfig {
        config: TlsConfig {
            cert_file: Some(server_cert_path.clone()),
            key_file: Some(server_key_path),
            cert_pem: None,
            key_pem: None,
            reload_interval: None,
        },
        client_ca_file: Some(client_cert_path.clone()),
        client_ca_pem: None,
        include_system_ca_certs_pool: None,
        handshake_timeout: None,
    };

    let server_config = build_reloadable_server_config(&config)
        .await
        .expect("Failed to build server config");
    let tls_acceptor = tokio_rustls::TlsAcceptor::from(server_config);

    // 4. Start Server
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind");
    let addr = listener.local_addr().expect("Failed to get addr");

    let server_task = tokio::spawn(async move {
        let (stream, _) = listener.accept().await.expect("Failed to accept");
        match tls_acceptor.accept(stream).await {
            Ok(_tls_stream) => true,
            Err(e) => {
                log::debug!("Server handshake failed: {}", e);
                false
            }
        }
    });

    // 5. Client Connection (Success Case)
    let mut root_store = rustls::RootCertStore::empty();
    let server_cert_pem = fs::read_to_string(&server_cert_path).expect("Read server cert");
    for cert in CertificateDer::pem_reader_iter(&mut io::BufReader::new(server_cert_pem.as_bytes()))
    {
        root_store
            .add(cert.expect("Parse cert"))
            .expect("Add cert to root store");
    }

    let client_cert_pem = fs::read_to_string(&client_cert_path).expect("Read client cert");
    let client_key_pem = fs::read_to_string(&client_key_path).expect("Read client key");

    let client_certs: Vec<_> =
        CertificateDer::pem_reader_iter(&mut io::BufReader::new(client_cert_pem.as_bytes()))
            .collect::<Result<_, _>>()
            .expect("Parse client certs");
    let client_key =
        PrivateKeyDer::from_pem_reader(&mut io::BufReader::new(client_key_pem.as_bytes()))
            .expect("Parse client key");

    let client_config = rustls::ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_client_auth_cert(client_certs, client_key)
        .expect("Failed to build client config");

    let connector = tokio_rustls::TlsConnector::from(Arc::new(client_config));
    let stream = tokio::net::TcpStream::connect(addr)
        .await
        .expect("Failed to connect");
    let domain = rustls::pki_types::ServerName::try_from("localhost").expect("Parse domain");

    let _ = connector
        .connect(domain, stream)
        .await
        .expect("Client handshake failed");

    assert!(
        server_task.await.expect("Server task panicked"),
        "Server should accept valid client cert"
    );
}

#[tokio::test]
async fn test_mtls_missing_client_cert() {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let _ = rustls::crypto::ring::default_provider().install_default();

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let path = temp_dir.path();

    let client_cert = generate_cert("Test Client", None, false);
    let client_cert_path = path.join("client.crt");
    fs::write(&client_cert_path, &client_cert.cert_pem).expect("Write client cert");

    let server_cert = generate_cert("localhost", Some("localhost"), false);
    let server_cert_path = path.join("server.crt");
    let server_key_path = path.join("server.key");
    fs::write(&server_cert_path, &server_cert.cert_pem).expect("Write server cert");
    fs::write(&server_key_path, &server_cert.key_pem).expect("Write server key");

    let config = TlsServerConfig {
        config: TlsConfig {
            cert_file: Some(server_cert_path.clone()),
            key_file: Some(server_key_path),
            cert_pem: None,
            key_pem: None,
            reload_interval: None,
        },
        client_ca_file: Some(client_cert_path.clone()),
        client_ca_pem: None,
        include_system_ca_certs_pool: None,
        handshake_timeout: None,
    };

    let server_config = build_reloadable_server_config(&config)
        .await
        .expect("Failed to build server config");
    let tls_acceptor = tokio_rustls::TlsAcceptor::from(server_config);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind");
    let addr = listener.local_addr().expect("Failed to get addr");

    let server_task = tokio::spawn(async move {
        let (stream, _) = listener.accept().await.expect("Failed to accept");
        match tls_acceptor.accept(stream).await {
            Ok(_) => true,
            Err(e) => {
                log::info!("Server correctly rejected client: {}", e);
                false
            }
        }
    });

    let mut root_store = rustls::RootCertStore::empty();
    let server_cert_pem = fs::read_to_string(&server_cert_path).expect("Read server cert");
    for cert in CertificateDer::pem_reader_iter(&mut io::BufReader::new(server_cert_pem.as_bytes()))
    {
        root_store
            .add(cert.expect("Parse cert"))
            .expect("Add cert to root store");
    }

    let client_config = rustls::ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();

    let connector = tokio_rustls::TlsConnector::from(Arc::new(client_config));
    let stream = tokio::net::TcpStream::connect(addr)
        .await
        .expect("Failed to connect");
    let domain = rustls::pki_types::ServerName::try_from("localhost").expect("Parse domain");

    // The TLS handshake might appear to succeed from the client side initially,
    // but the server will reject it. We need to try I/O to see the rejection.
    let handshake_or_io_failed = match connector.connect(domain, stream).await {
        Err(_) => true, // Handshake failed immediately
        Ok(mut tls_stream) => {
            // Try to write and read - this will fail if server rejected us
            let write_result = tls_stream.write_all(b"test").await;
            if write_result.is_err() {
                true
            } else {
                let mut buf = [0u8; 1];
                let read_result = tls_stream.read(&mut buf).await;
                // Connection should be closed/reset by server
                matches!(read_result, Err(_) | Ok(0))
            }
        }
    };

    let server_rejected = !server_task.await.expect("Server task panicked");
    assert!(server_rejected, "Server should reject missing client cert");
    assert!(
        handshake_or_io_failed,
        "Client should detect connection failure"
    );
}

#[tokio::test]
async fn test_mtls_wrong_client_cert() {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let _ = rustls::crypto::ring::default_provider().install_default();

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let path = temp_dir.path();

    let trusted_client_cert = generate_cert("Trusted Client", None, false);
    let trusted_client_cert_path = path.join("trusted_client.crt");
    fs::write(&trusted_client_cert_path, &trusted_client_cert.cert_pem)
        .expect("Write trusted client cert");

    let untrusted_client_cert = generate_cert("Untrusted Client", None, false);
    let untrusted_client_cert_path = path.join("untrusted_client.crt");
    let untrusted_client_key_path = path.join("untrusted_client.key");
    fs::write(&untrusted_client_cert_path, &untrusted_client_cert.cert_pem)
        .expect("Write untrusted client cert");
    fs::write(&untrusted_client_key_path, &untrusted_client_cert.key_pem)
        .expect("Write untrusted client key");

    let server_cert = generate_cert("localhost", Some("localhost"), false);
    let server_cert_path = path.join("server.crt");
    let server_key_path = path.join("server.key");
    fs::write(&server_cert_path, &server_cert.cert_pem).expect("Write server cert");
    fs::write(&server_key_path, &server_cert.key_pem).expect("Write server key");

    let config = TlsServerConfig {
        config: TlsConfig {
            cert_file: Some(server_cert_path.clone()),
            key_file: Some(server_key_path),
            cert_pem: None,
            key_pem: None,
            reload_interval: None,
        },
        client_ca_file: Some(trusted_client_cert_path.clone()),
        client_ca_pem: None,
        include_system_ca_certs_pool: None,
        handshake_timeout: None,
    };

    let server_config = build_reloadable_server_config(&config)
        .await
        .expect("Failed to build server config");
    let tls_acceptor = tokio_rustls::TlsAcceptor::from(server_config);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind");
    let addr = listener.local_addr().expect("Failed to get addr");

    let server_task = tokio::spawn(async move {
        let (stream, _) = listener.accept().await.expect("Failed to accept");
        match tls_acceptor.accept(stream).await {
            Ok(_) => true,
            Err(e) => {
                log::info!("Server correctly rejected untrusted client: {}", e);
                false
            }
        }
    });

    let mut root_store = rustls::RootCertStore::empty();
    let server_cert_pem = fs::read_to_string(&server_cert_path).expect("Read server cert");
    for cert in CertificateDer::pem_reader_iter(&mut io::BufReader::new(server_cert_pem.as_bytes()))
    {
        root_store
            .add(cert.expect("Parse cert"))
            .expect("Add cert to root store");
    }

    let client_cert_pem =
        fs::read_to_string(&untrusted_client_cert_path).expect("Read client cert");
    let client_key_pem = fs::read_to_string(&untrusted_client_key_path).expect("Read client key");

    let client_certs: Vec<_> =
        CertificateDer::pem_reader_iter(&mut io::BufReader::new(client_cert_pem.as_bytes()))
            .collect::<Result<_, _>>()
            .expect("Parse client certs");
    let client_key =
        PrivateKeyDer::from_pem_reader(&mut io::BufReader::new(client_key_pem.as_bytes()))
            .expect("Parse client key");

    let client_config = rustls::ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_client_auth_cert(client_certs, client_key)
        .expect("Failed to build client config");

    let connector = tokio_rustls::TlsConnector::from(Arc::new(client_config));
    let stream = tokio::net::TcpStream::connect(addr)
        .await
        .expect("Failed to connect");
    let domain = rustls::pki_types::ServerName::try_from("localhost").expect("Parse domain");

    // The TLS handshake might appear to succeed from the client side initially,
    // but the server will reject it. We need to try I/O to see the rejection.
    let handshake_or_io_failed = match connector.connect(domain, stream).await {
        Err(_) => true, // Handshake failed immediately
        Ok(mut tls_stream) => {
            // Try to write and read - this will fail if server rejected us
            let write_result = tls_stream.write_all(b"test").await;
            if write_result.is_err() {
                true
            } else {
                let mut buf = [0u8; 1];
                let read_result = tls_stream.read(&mut buf).await;
                // Connection should be closed/reset by server
                matches!(read_result, Err(_) | Ok(0))
            }
        }
    };

    let server_rejected = !server_task.await.expect("Server task panicked");
    assert!(
        server_rejected,
        "Server should reject untrusted client cert"
    );
    assert!(
        handshake_or_io_failed,
        "Client should detect connection failure"
    );
}

#[tokio::test]
async fn test_build_server_config_corrupted_pem() {
    let _ = rustls::crypto::ring::default_provider().install_default();

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let path = temp_dir.path();

    let server_cert = generate_cert("localhost", Some("localhost"), false);
    let cert_path = path.join("server.crt");
    let key_path = path.join("server.key");
    fs::write(&cert_path, &server_cert.cert_pem).expect("Write server cert");

    fs::write(&key_path, "NOT A VALID KEY").expect("Write corrupted key");

    let config = TlsServerConfig {
        config: TlsConfig {
            cert_file: Some(cert_path),
            key_file: Some(key_path),
            cert_pem: None,
            key_pem: None,
            reload_interval: None,
        },
        client_ca_file: None,
        client_ca_pem: None,
        include_system_ca_certs_pool: None,
        handshake_timeout: None,
    };

    let result = build_reloadable_server_config(&config).await;
    assert!(result.is_err(), "Should fail with corrupted key");
}
